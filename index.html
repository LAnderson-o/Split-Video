<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Split-Video</title>
  <style>
    * { box-sizing: border-box; }
    body { 
      margin: 0; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      display: flex; 
      flex-direction: column; 
      height: 100vh; 
      overflow: hidden; 
      background: #000; 
      color: #fff;
      -webkit-font-smoothing: antialiased;
    }
    
    /* Video Layout */
    .video-container { 
      flex: 1; 
      display: flex; 
      position: relative;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .video-container:last-child { border-bottom: none; }
    
    video { 
      width: 100%; 
      height: 100%; 
      object-fit: cover; 
      background: #111; 
      transition: opacity 0.2s ease;
    }
    video.loading { opacity: 0.7; }
    video.error { opacity: 0.5; }
    
    /* Video overlays */
    .video-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.3);
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
      font-size: 0.875rem;
      color: rgba(255,255,255,0.8);
    }
    .video-overlay.show { opacity: 1; }
    
    /* Cursor */
    #cursor { 
      position: absolute; 
      width: 12px; 
      height: 12px; 
      border-radius: 50%; 
      background: #ff4444; 
      border: 2px solid rgba(255,255,255,0.8);
      pointer-events: none; 
      transform: translate(-50%,-50%); 
      z-index: 20;
      transition: opacity 0.2s ease;
    }
    
    /* Top UI */
    #unlock { 
      position: absolute; 
      top: 16px; 
      left: 50%; 
      transform: translateX(-50%); 
      background: rgba(0,0,0,0.8); 
      backdrop-filter: blur(10px);
      color: #fff; 
      padding: 12px 20px; 
      border-radius: 20px; 
      cursor: pointer; 
      z-index: 10;
      font-size: 0.875rem;
      font-weight: 500;
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.2s ease;
    }
    #unlock:hover { background: rgba(0,0,0,0.9); }
    
    #startButton { 
      position: absolute; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%,-50%); 
      padding: 20px 32px; 
      background: #fff; 
      color: #000; 
      font-size: 1rem; 
      font-weight: 600;
      border-radius: 16px; 
      cursor: pointer; 
      z-index: 50;
      border: none;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      transition: all 0.2s ease;
    }
    #startButton:hover { transform: translate(-50%,-50%) scale(1.02); }
    
    /* Calibration */
    #calibrationOverlay { 
      position: absolute; 
      inset: 0; 
      background: rgba(0,0,0,0.9); 
      backdrop-filter: blur(10px);
      display: none; 
      align-items: center; 
      justify-content: center; 
      flex-direction: column; 
      z-index: 30; 
      color: #fff; 
      font-size: 1.125rem;
      text-align: center;
    }
    #calibrationOverlay p { 
      margin: 0 0 3rem 0; 
      z-index: 31; 
      font-weight: 500;
    }
    .calibration-dot { 
      position: absolute; 
      width: 32px; 
      height: 32px; 
      background: #ffeb3b; 
      border-radius: 50%; 
      transform: translate(-50%,-50%); 
      z-index: 32; 
      cursor: pointer;
      box-shadow: 0 0 20px rgba(255,235,59,0.6);
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: translate(-50%,-50%) scale(1); }
      50% { transform: translate(-50%,-50%) scale(1.1); }
    }
    
    /* Controls */
    #modeBadge { 
      position: absolute; 
      left: 16px; 
      top: 16px; 
      background: rgba(0,0,0,0.7); 
      backdrop-filter: blur(10px);
      color: #fff; 
      padding: 8px 12px; 
      border-radius: 12px; 
      font-size: 0.75rem; 
      font-weight: 500;
      z-index: 40;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    #controls { 
      position: absolute; 
      right: 16px; 
      top: 16px; 
      display: flex; 
      gap: 8px; 
      z-index: 40; 
    }
    
    .btn { 
      -webkit-tap-highlight-color: transparent; 
      background: rgba(255,255,255,0.95); 
      color: #000; 
      border: none; 
      border-radius: 12px; 
      padding: 10px 14px; 
      font-size: 0.875rem; 
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 40px;
    }
    .btn:hover { background: #fff; transform: translateY(-1px); }
    .btn.ghost { 
      background: rgba(0,0,0,0.7); 
      backdrop-filter: blur(10px);
      color: #fff; 
      border: 1px solid rgba(255,255,255,0.2); 
    }
    .btn.ghost:hover { background: rgba(0,0,0,0.8); }
    
    /* Bottom Sheet */
    #sheet { 
      position: absolute; 
      left: 0; 
      right: 0; 
      bottom: 0; 
      background: rgba(0,0,0,0.95); 
      backdrop-filter: blur(20px);
      color: #fff; 
      z-index: 45; 
      transform: translateY(100%); 
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
      border-top-left-radius: 20px; 
      border-top-right-radius: 20px;
      border-top: 1px solid rgba(255,255,255,0.1);
      max-height: 60vh;
      overflow-y: auto;
    }
    #sheet.open { transform: translateY(0); }
    
    #sheetHeader { 
      display: flex; 
      align-items: center; 
      justify-content: space-between; 
      padding: 20px 20px 16px; 
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    #sheetHeader strong { font-size: 1.125rem; font-weight: 600; }
    
    #sheetContent { 
      padding: 20px; 
      display: grid; 
      gap: 24px; 
    }
    
    .row { 
      display: flex; 
      align-items: center; 
      gap: 12px; 
      flex-wrap: wrap; 
    }
    
    .pill { 
      background: rgba(255,255,255,0.1); 
      padding: 6px 12px; 
      border-radius: 16px; 
      font-size: 0.75rem; 
      font-weight: 500;
      color: rgba(255,255,255,0.8);
      min-width: 80px;
      text-align: center;
    }
    
    #playlist { 
      display: flex; 
      overflow-x: auto; 
      gap: 8px; 
      padding: 12px 0 16px;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    #playlist::-webkit-scrollbar { display: none; }
    
    .chip { 
      flex: 0 0 auto; 
      background: rgba(255,255,255,0.08); 
      color: #fff; 
      border: 1px solid rgba(255,255,255,0.15); 
      padding: 8px 12px; 
      border-radius: 16px; 
      font-size: 0.75rem;
      font-weight: 500;
      white-space: nowrap;
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    input[type="file"] { display: none; }
    
    /* Responsive */
    @media (max-width: 480px) {
      #controls { gap: 6px; }
      .btn { padding: 8px 12px; font-size: 0.8125rem; }
      #sheetContent { padding: 16px; gap: 20px; }
      .row { gap: 8px; }
    }
    
    /* Safe areas */
    @supports (padding: env(safe-area-inset-top)) {
      #modeBadge { top: calc(16px + env(safe-area-inset-top)); }
      #controls { top: calc(16px + env(safe-area-inset-top)); }
      #unlock { top: calc(16px + env(safe-area-inset-top)); }
      #sheet { padding-bottom: env(safe-area-inset-bottom); }
    }
  </style>
</head>
<body>
  <div class="video-container">
    <video id="video1" muted loop playsinline></video>
    <div class="video-overlay" id="overlay1">Loading...</div>
  </div>
  <div class="video-container">
    <video id="video2" muted loop playsinline></video>
    <div class="video-overlay" id="overlay2">Loading...</div>
  </div>

  <div id="cursor"></div>
  <div id="unlock">ðŸ”Š Tap to Enable Sound</div>
  <div id="startButton">Start Calibration</div>

  <div id="calibrationOverlay">
    <p>Look at the yellow dot and tap it</p>
    <div id="calibrationDot" class="calibration-dot"></div>
  </div>

  <div id="modeBadge">Mode: Gaze</div>
  <div id="controls">
    <button id="toggleMode" class="btn">Use Pointer</button>
    <button id="recalibrate" class="btn">Recalibrate</button>
    <button id="openSheet" class="btn ghost">â‹¯</button>
  </div>

  <div id="sheet" aria-hidden="true">
    <div id="sheetHeader">
      <strong>Controls</strong>
      <button id="closeSheet" class="btn">Close</button>
    </div>
    <div id="sheetContent">
      <div class="row">
        <span class="pill">Playback</span>
        <button id="toggleMute" class="btn">Unmute</button>
        <button id="swapNow" class="btn ghost">Swap Now</button>
      </div>
      <div class="row">
        <span class="pill">Mode</span>
        <button id="modeGaze" class="btn">Gaze</button>
        <button id="modePointer" class="btn ghost">Pointer</button>
        <button id="toggleCursor" class="btn ghost">Hide Cursor</button>
      </div>
      <div class="row">
        <span class="pill">Upload</span>
        <button id="uploadBtn" class="btn">Add Videos</button>
        <input id="fileInput" type="file" accept="video/*" multiple>
        <button id="resetLibrary" class="btn ghost">Reset Library</button>
      </div>
      <div>
        <div style="opacity:.7; font-size:12px; margin-bottom:6px;">Queue</div>
        <div id="playlist"></div>
      </div>
    </div>
  </div>

<script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
<script>
const video1 = document.getElementById("video1");
const video2 = document.getElementById("video2");
const overlay1 = document.getElementById("overlay1");
const overlay2 = document.getElementById("overlay2");
const cursor = document.getElementById("cursor");
const unlock = document.getElementById("unlock");
const calibrationOverlay = document.getElementById("calibrationOverlay");
const calibrationDot = document.getElementById("calibrationDot");
const startButton = document.getElementById("startButton");
const modeBadge = document.getElementById("modeBadge");
const toggleModeBtn = document.getElementById("toggleMode");
const recalibrateBtn = document.getElementById("recalibrate");
const openSheetBtn = document.getElementById("openSheet");
const closeSheetBtn = document.getElementById("closeSheet");
const sheet = document.getElementById("sheet");
const toggleMuteBtn = document.getElementById("toggleMute");
const swapNowBtn = document.getElementById("swapNow");
const modeGazeBtn = document.getElementById("modeGaze");
const modePointerBtn = document.getElementById("modePointer");
const toggleCursorBtn = document.getElementById("toggleCursor");
const uploadBtn = document.getElementById("uploadBtn");
const fileInput = document.getElementById("fileInput");
const resetLibraryBtn = document.getElementById("resetLibrary");
const playlistEl = document.getElementById("playlist");

let active = null;
let lastAttended = null;
let mode = localStorage.getItem("mode") || "gaze"; // 'gaze' | 'pointer'
let showCursor = localStorage.getItem("showCursor") !== "false"; // default true
let videoLibrary = [];
let nextIndex = 0;
let isWebgazerStarted = false;
let pointerY = null;

function defaultLibrary() {
  return [
    { src: "https://www.w3schools.com/html/mov_bbb.mp4", name: "Big Buck Bunny" },
    { src: "https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4", name: "Flower" },
    { src: "https://www.w3schools.com/html/movie.mp4", name: "Bear" },
    { src: "https://interactive-examples.mdn.mozilla.net/media/cc0-videos/bee.mp4", name: "Bee" },
    { src: "https://interactive-examples.mdn.mozilla.net/media/cc0-videos/earth.mp4", name: "Earth" }
  ];
}

function initLibrary(reset=false) {
  if (!reset) {
    try {
      const saved = JSON.parse(localStorage.getItem("library") || "null");
      if (saved && Array.isArray(saved) && saved.length) {
        videoLibrary = saved;
      } else {
        videoLibrary = defaultLibrary();
      }
    } catch(_) {
      videoLibrary = defaultLibrary();
    }
  } else {
    videoLibrary = defaultLibrary();
  }
  nextIndex = 0;
  renderPlaylist();
}

function persistLibrary() {
  localStorage.setItem("library", JSON.stringify(videoLibrary));
}

function renderPlaylist() {
  playlistEl.innerHTML = "";
  videoLibrary.forEach((item, i) => {
    const div = document.createElement('div');
    div.className = 'chip';
    div.textContent = item.name || `Video ${i+1}`;
    playlistEl.appendChild(div);
  });
}

function getVideoOverlay(videoEl) {
  return videoEl === video1 ? overlay1 : overlay2;
}

function showVideoState(videoEl, state, message) {
  const overlay = getVideoOverlay(videoEl);
  overlay.textContent = message;
  videoEl.className = state;
  overlay.className = `video-overlay ${state === 'loading' || state === 'error' ? 'show' : ''}`;
}

function isValidVideoFormat(src) {
  if (!src) return false;
  // Check for supported video formats and avoid problematic sources
  const supportedFormats = /\.(mp4|webm|ogg|mov)(\?.*)?$/i;
  const isDataUrl = src.startsWith('data:');
  const isBlobUrl = src.startsWith('blob:');
  const isHttpUrl = src.startsWith('http');
  
  return isDataUrl || isBlobUrl || (isHttpUrl && supportedFormats.test(src));
}

function loadVideo(videoEl, libIndex) {
  const item = videoLibrary[libIndex % videoLibrary.length];
  if (!item || !isValidVideoFormat(item.src)) {
    showVideoState(videoEl, 'error', 'Invalid video format');
    return;
  }
  
  videoEl.dataset.libIndex = String(libIndex % videoLibrary.length);
  showVideoState(videoEl, 'loading', 'Loading...');
  
  // Clear previous event listeners
  videoEl.onloadeddata = null;
  videoEl.onerror = null;
  videoEl.oncanplay = null;
  
  videoEl.onloadeddata = () => {
    showVideoState(videoEl, '', '');
    // Auto-play if this is the active video
    if (active === videoEl && !videoEl.muted) {
      videoEl.play().catch(() => {});
    }
  };
  
  videoEl.onerror = () => {
    console.warn('Video load error:', item.src);
    showVideoState(videoEl, 'error', 'Failed to load');
    // Try next video after a delay
    setTimeout(() => {
      const nextIdx = getNextIndex(parseInt(videoEl.dataset.libIndex, 10));
      if (nextIdx !== libIndex) loadVideo(videoEl, nextIdx);
    }, 2000);
  };
  
  videoEl.oncanplay = () => {
    showVideoState(videoEl, '', '');
  };
  
  videoEl.src = item.src;
  videoEl.load();
}

function getNextIndex(excludeLibIndex) {
  if (!videoLibrary.length) return 0;
  // Ensure not identical to exclude when possible
  for (let i = 0; i < videoLibrary.length; i++) {
    const candidate = (nextIndex + i) % videoLibrary.length;
    if (candidate !== excludeLibIndex) {
      nextIndex = (candidate + 1) % videoLibrary.length;
      return candidate;
    }
  }
  const val = nextIndex; nextIndex = (nextIndex + 1) % videoLibrary.length; return val;
}

function cycleVideo(videoEl) {
  const other = (videoEl === video1) ? video2 : video1;
  const exclude = other.dataset.libIndex ? parseInt(other.dataset.libIndex, 10) : -1;
  const idx = getNextIndex(exclude);
  loadVideo(videoEl, idx);
}

function activate(video) {
  if (active === video) return;
  if (active) active.pause();
  video.play();
  active = video;
}

unlock.addEventListener("click", () => {
  [video1, video2].forEach(v => { v.muted = false; v.play().catch(() => {}); });
  unlock.style.display = "none";
});

toggleMuteBtn.addEventListener('click', () => {
  const willUnmute = video1.muted || video2.muted;
  [video1, video2].forEach(v => { v.muted = !willUnmute ? true : false; if (!v.paused) v.play().catch(()=>{}); });
  if (!willUnmute) unlock.style.display = "block";
});

const points = [[10,10],[90,10],[50,50],[10,90],[90,90]];
let currentPoint = 0;

function showCalibrationPoint() {
  if (currentPoint >= points.length) { calibrationOverlay.style.display = "none"; startTracking(); return; }
  const [px, py] = points[currentPoint];
  calibrationDot.style.left = `${Math.min(Math.max(px, 5), 95)}%`;
  calibrationDot.style.top = `${Math.min(Math.max(py, 5), 95)}%`;
}

calibrationDot.addEventListener("click", () => {
  try { webgazer.recordScreenPosition(calibrationDot.offsetLeft, calibrationDot.offsetTop, "click"); } catch(_) {}
  currentPoint++;
  showCalibrationPoint();
});

function updateModeUI() {
  modeBadge.textContent = `Mode: ${mode === 'gaze' ? 'Gaze' : 'Pointer'}`;
  toggleModeBtn.textContent = mode === 'gaze' ? 'Use Pointer' : 'Use Gaze';
  cursor.style.display = showCursor ? 'block' : 'none';
  toggleCursorBtn.textContent = showCursor ? 'Hide Cursor' : 'Show Cursor';
  localStorage.setItem('mode', mode);
  localStorage.setItem('showCursor', String(showCursor));
}

function handleAttentionAt(y) {
  if (typeof y !== 'number') return;
  if (showCursor) {
    cursor.style.left = `${window.innerWidth / 2}px`;
    cursor.style.top = `${y}px`;
  }
  const half = window.innerHeight / 2;
  let currentlyLookingAt = (y < half) ? video1 : video2;
  if (currentlyLookingAt !== lastAttended) {
    activate(currentlyLookingAt);
    const nonActive = (currentlyLookingAt === video1) ? video2 : video1;
    cycleVideo(nonActive);
    lastAttended = currentlyLookingAt;
  }
}

function startPointerTracking() {
  window.addEventListener('pointermove', pointerMoveListener);
  window.addEventListener('pointerdown', pointerMoveListener);
}

function stopPointerTracking() {
  window.removeEventListener('pointermove', pointerMoveListener);
  window.removeEventListener('pointerdown', pointerMoveListener);
}

function pointerMoveListener(e) {
  pointerY = e.clientY;
  handleAttentionAt(pointerY);
}

function ensureWebgazerStarted() {
  if (isWebgazerStarted) return Promise.resolve();
  try {
    return webgazer.setRegression('ridge').showVideo(false).showPredictionPoints(false).begin().then(() => {
      isWebgazerStarted = true;
      const style = document.createElement('style');
      style.innerHTML = "#webgazerVideoFeed, #webgazerVideoCanvas, #webgazerFaceOverlay, #webgazerFaceFeedbackBox { display: none !important; }";
      document.head.appendChild(style);
    });
  } catch (e) {
    return Promise.reject(e);
  }
}

function startGazeTracking() {
  try {
    webgazer.setGazeListener((data) => {
      if (!data) return;
      const y = data.y;
      if (showCursor) {
        cursor.style.left = `${data.x}px`;
        cursor.style.top = `${y}px`;
      }
      handleAttentionAt(y);
    });
  } catch(_) {}
}

function stopGazeTracking() {
  try { webgazer.clearGazeListener(); } catch(_) {}
}

function startCalibrationFlow() {
  currentPoint = 0;
  calibrationOverlay.style.display = "flex";
  showCalibrationPoint();
}

function finishCalibration() {
  calibrationOverlay.style.display = "none";
  // Initialize tracking based on current mode
  if (mode === 'gaze') {
    ensureWebgazerStarted().then(() => {
      startGazeTracking();
    }).catch(err => {
      mode = 'pointer';
      updateModeUI();
      startPointerTracking();
      alert("Camera access denied. Switched to Pointer mode.");
      console.error(err);
    });
  } else {
    startPointerTracking();
  }
}

startButton.addEventListener("click", () => {
  startButton.style.display = "none";
  if (mode === 'gaze') {
    ensureWebgazerStarted().then(() => {
      startCalibrationFlow();
    }).catch(err => {
      mode = 'pointer';
      updateModeUI();
      startPointerTracking();
      alert("Camera access denied. Using Pointer mode.");
      console.error(err);
    });
  } else {
    startCalibrationFlow();
  }
});

// Complete calibration after tapping through points
const origShowCalibrationPoint = showCalibrationPoint;
showCalibrationPoint = function() {
  if (currentPoint >= points.length) { finishCalibration(); return; }
  const [px, py] = points[currentPoint];
  calibrationDot.style.left = `${Math.min(Math.max(px, 5), 95)}%`;
  calibrationDot.style.top = `${Math.min(Math.max(py, 5), 95)}%`;
}

// Controls wiring
openSheetBtn.addEventListener('click', () => { sheet.classList.add('open'); sheet.setAttribute('aria-hidden','false'); });
closeSheetBtn.addEventListener('click', () => { sheet.classList.remove('open'); sheet.setAttribute('aria-hidden','true'); });
recalibrateBtn.addEventListener('click', () => { sheet.classList.remove('open'); startCalibrationFlow(); });
toggleModeBtn.addEventListener('click', () => {
  mode = mode === 'gaze' ? 'pointer' : 'gaze';
  applyMode();
});
modeGazeBtn.addEventListener('click', () => { mode = 'gaze'; applyMode(); });
modePointerBtn.addEventListener('click', () => { mode = 'pointer'; applyMode(); });
toggleCursorBtn.addEventListener('click', () => { showCursor = !showCursor; updateModeUI(); });
swapNowBtn.addEventListener('click', () => {
  const nonActive = (active === video1) ? video2 : video1;
  cycleVideo(nonActive);
});
uploadBtn.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', (e) => {
  const files = Array.from(e.target.files || []);
  if (!files.length) return;
  
  let validCount = 0;
  let invalidCount = 0;
  
  files.forEach(f => {
    // Validate file type
    const validTypes = ['video/mp4', 'video/webm', 'video/ogg', 'video/quicktime'];
    const isValidType = validTypes.includes(f.type) || /\.(mp4|webm|ogg|mov)$/i.test(f.name);
    
    if (isValidType && f.size > 0) {
      const url = URL.createObjectURL(f);
      videoLibrary.push({ src: url, name: f.name });
      validCount++;
    } else {
      invalidCount++;
    }
  });
  
  if (validCount > 0) {
    persistLibrary();
    renderPlaylist();
    // If we had fewer than 2 before, ensure both screens are filled
    if (!video1.src) loadVideo(video1, 0);
    if (!video2.src) loadVideo(video2, 1);
  }
  
  if (invalidCount > 0) {
    alert(`${invalidCount} file(s) skipped. Please upload MP4, WebM, OGG, or MOV videos.`);
  }
  
  // Clear the input
  e.target.value = '';
});
resetLibraryBtn.addEventListener('click', () => { initLibrary(true); persistLibrary(); renderPlaylist(); });

function applyMode() {
  updateModeUI();
  if (mode === 'gaze') {
    stopPointerTracking();
    ensureWebgazerStarted().then(() => { startGazeTracking(); }).catch(() => {
      mode = 'pointer'; updateModeUI(); startPointerTracking();
    });
  } else {
    stopGazeTracking();
    startPointerTracking();
  }
}

// Init
initLibrary(false);
loadVideo(video1, 0);
loadVideo(video2, 1);
updateModeUI();

// Start both muted for autoplay compatibility
[video1, video2].forEach(v => { v.muted = true; v.play().catch(()=>{}); });
</script>
</body>
</html>
