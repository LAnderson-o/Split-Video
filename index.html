<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Split-Video</title>
  <style>
    * { box-sizing: border-box; }
    body { 
      margin: 0; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      display: flex; 
      flex-direction: column; 
      height: 100vh; 
      overflow: hidden; 
      background: #000; 
      color: #fff;
      -webkit-font-smoothing: antialiased;
    }
    
    /* Video Layout */
    .video-container { 
      flex: 1; 
      display: flex; 
      position: relative;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .video-container:last-child { border-bottom: none; }
    
    video { 
      width: 100%; 
      height: 100%; 
      object-fit: cover; 
      background: #111; 
      transition: opacity 0.2s ease;
    }
    video.loading { opacity: 0.7; }
    video.error { opacity: 0.5; }
    
    /* Video overlays */
    .video-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.3);
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
      font-size: 0.875rem;
      color: rgba(255,255,255,0.8);
    }
    .video-overlay.show { opacity: 1; }
    
    /* Cursor */
    #cursor { 
      position: absolute; 
      width: 12px; 
      height: 12px; 
      border-radius: 50%; 
      background: #ff4444; 
      border: 2px solid rgba(255,255,255,0.8);
      pointer-events: none; 
      transform: translate(-50%,-50%); 
      z-index: 20;
      transition: opacity 0.2s ease;
    }
    
    /* Top UI */
    #unlock { 
      position: absolute; 
      top: 16px; 
      left: 50%; 
      transform: translateX(-50%); 
      background: rgba(0,0,0,0.8); 
      backdrop-filter: blur(10px);
      color: #fff; 
      padding: 12px 20px; 
      border-radius: 20px; 
      cursor: pointer; 
      z-index: 10;
      font-size: 0.875rem;
      font-weight: 500;
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.2s ease;
    }
    #unlock:hover { background: rgba(0,0,0,0.9); }
    
    #startButton { 
      position: absolute; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%,-50%); 
      padding: 20px 32px; 
      background: #fff; 
      color: #000; 
      font-size: 1rem; 
      font-weight: 600;
      border-radius: 16px; 
      cursor: pointer; 
      z-index: 50;
      border: none;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      transition: all 0.2s ease;
    }
    #startButton:hover { transform: translate(-50%,-50%) scale(1.02); }
    
    /* Calibration */
    #calibrationOverlay { 
      position: absolute; 
      inset: 0; 
      background: rgba(0,0,0,0.9); 
      backdrop-filter: blur(10px);
      display: none; 
      align-items: center; 
      justify-content: center; 
      flex-direction: column; 
      z-index: 30; 
      color: #fff; 
      font-size: 1.125rem;
      text-align: center;
    }
    #calibrationOverlay p { 
      margin: 0 0 3rem 0; 
      z-index: 31; 
      font-weight: 500;
    }
    .calibration-dot { 
      position: absolute; 
      width: 32px; 
      height: 32px; 
      background: #ffeb3b; 
      border-radius: 50%; 
      transform: translate(-50%,-50%); 
      z-index: 32; 
      cursor: pointer;
      box-shadow: 0 0 20px rgba(255,235,59,0.6);
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: translate(-50%,-50%) scale(1); }
      50% { transform: translate(-50%,-50%) scale(1.1); }
    }
    
    /* Top Menu */
    #topMenu {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.9);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      z-index: 1000;
      transform: translateY(-100%);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    #topMenu.open { transform: translateY(0); }
    
    #menuToggle {
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(255,255,255,0.95);
      color: #000;
      border: none;
      border-radius: 12px;
      padding: 12px 16px;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      z-index: 1001;
      transition: all 0.2s ease;
      min-height: 44px;
    }
    #menuToggle:hover { background: #fff; transform: translateY(-1px); }
    
    #menuContent {
      padding: 20px;
      display: grid;
      gap: 16px;
    }
    
    .menuSection {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    
    .menuSectionTitle {
      font-size: 0.75rem;
      font-weight: 600;
      color: rgba(255,255,255,0.7);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
      width: 100%;
    }
    
    .menuBtn {
      background: rgba(255,255,255,0.1);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 0.8125rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 36px;
    }
    .menuBtn:hover { background: rgba(255,255,255,0.2); }
    .menuBtn.active { background: rgba(255,255,255,0.3); border-color: rgba(255,255,255,0.4); }
    
    /* Primary and secondary button styles */
    .menuBtn.primary {
      background: rgba(255,255,255,0.15);
      border-color: rgba(255,255,255,0.3);
      font-weight: 600;
    }
    .menuBtn.primary:hover { background: rgba(255,255,255,0.25); }
    
    .menuBtn.secondary {
      background: rgba(255,255,255,0.08);
      border-color: rgba(255,255,255,0.15);
    }
    .menuBtn.secondary:hover { background: rgba(255,255,255,0.15); }
    
    /* Submenu styles */
    .submenu {
      border-top: 1px solid rgba(255,255,255,0.1);
      padding-top: 16px;
      margin-top: 16px;
    }
    
    /* Hide old controls */
    #controls, #modeBadge { display: none; }
    
    /* Bottom Sheet */
    #sheet { 
      position: absolute; 
      left: 0; 
      right: 0; 
      bottom: 0; 
      background: rgba(0,0,0,0.95); 
      backdrop-filter: blur(20px);
      color: #fff; 
      z-index: 45; 
      transform: translateY(100%); 
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
      border-top-left-radius: 20px; 
      border-top-right-radius: 20px;
      border-top: 1px solid rgba(255,255,255,0.1);
      max-height: 60vh;
      overflow-y: auto;
    }
    #sheet.open { transform: translateY(0); }
    
    #sheetHeader { 
      display: flex; 
      align-items: center; 
      justify-content: space-between; 
      padding: 20px 20px 16px; 
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    #sheetHeader strong { font-size: 1.125rem; font-weight: 600; }
    
    #sheetContent { 
      padding: 20px; 
      display: grid; 
      gap: 24px; 
    }
    
    .row { 
      display: flex; 
      align-items: center; 
      gap: 12px; 
      flex-wrap: wrap; 
    }
    
    .pill { 
      background: rgba(255,255,255,0.1); 
      padding: 6px 12px; 
      border-radius: 16px; 
      font-size: 0.75rem; 
      font-weight: 500;
      color: rgba(255,255,255,0.8);
      min-width: 80px;
      text-align: center;
    }
    
    #playlist { 
      display: flex; 
      overflow-x: auto; 
      gap: 8px; 
      padding: 12px 0 16px;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    #playlist::-webkit-scrollbar { display: none; }
    
    .chip { 
      flex: 0 0 auto; 
      background: rgba(255,255,255,0.08); 
      color: #fff; 
      border: 1px solid rgba(255,255,255,0.15); 
      padding: 8px 12px; 
      border-radius: 16px; 
      font-size: 0.75rem;
      font-weight: 500;
      white-space: nowrap;
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    input[type="file"] { display: none; }
    
    /* Responsive */
    @media (max-width: 480px) {
      #menuContent { padding: 16px; gap: 12px; }
      .menuSection { gap: 6px; }
      .menuBtn { padding: 6px 10px; font-size: 0.75rem; min-height: 32px; }
      #menuToggle { padding: 10px 14px; font-size: 0.8125rem; min-height: 40px; }
      #sheetContent { padding: 16px; gap: 20px; }
      .row { gap: 8px; }
    }
    
    @media (max-width: 360px) {
      #menuToggle { right: 8px; top: 8px; }
      .menuBtn { padding: 5px 8px; font-size: 0.6875rem; min-height: 28px; }
    }
    
    /* Safe areas */
    @supports (padding: env(safe-area-inset-top)) {
      #menuToggle { top: calc(16px + env(safe-area-inset-top)); }
      #topMenu { padding-top: env(safe-area-inset-top); }
      #unlock { top: calc(16px + env(safe-area-inset-top)); }
      #sheet { padding-bottom: env(safe-area-inset-bottom); }
    }
  </style>
</head>
<body>
  <div class="video-container">
    <video id="video1" muted loop playsinline></video>
    <div class="video-overlay" id="overlay1">Loading...</div>
  </div>
  <div class="video-container">
    <video id="video2" muted loop playsinline></video>
    <div class="video-overlay" id="overlay2">Loading...</div>
  </div>

  <div id="cursor"></div>
  <div id="unlock">ðŸ”Š Tap to Enable Sound</div>
  <div id="startButton">Start Calibration</div>

  <div id="calibrationOverlay">
    <p>Look at the yellow dot and tap it</p>
    <div id="calibrationDot" class="calibration-dot"></div>
  </div>

  <!-- Top Menu -->
  <button id="menuToggle">â˜° Menu</button>
  <div id="topMenu">
    <div id="menuContent">
      <div class="menuSection">
        <div class="menuSectionTitle">Mode</div>
        <button id="menuModeGaze" class="menuBtn">Gaze</button>
        <button id="menuModePointer" class="menuBtn">Pointer</button>
        <button id="menuToggleCursor" class="menuBtn">Hide Cursor</button>
      </div>
      <div class="menuSection">
        <div class="menuSectionTitle">Calibration</div>
        <button id="menuStartCalibration" class="menuBtn">Start Calibration</button>
        <button id="menuRecalibrate" class="menuBtn">Recalibrate</button>
      </div>
      <div class="menuSection">
        <div class="menuSectionTitle">Playback</div>
        <button id="menuToggleMute" class="menuBtn">Unmute</button>
        <button id="menuSwapNow" class="menuBtn">Swap Now</button>
      </div>
      <div class="menuSection">
        <div class="menuSectionTitle">Upload</div>
        <button id="menuUploadBtn" class="menuBtn">Add Videos</button>
        <button id="menuResetLibrary" class="menuBtn">Reset Library</button>
      </div>
      <div class="menuSection">
        <div class="menuSectionTitle">Settings</div>
        <button id="menuOpenSheet" class="menuBtn">Advanced Settings</button>
      </div>
    </div>
  </div>

  <div id="modeBadge">Mode: Gaze</div>
  <div id="controls">
    <button id="toggleMode" class="btn">Use Pointer</button>
    <button id="recalibrate" class="btn">Recalibrate</button>
    <button id="openSheet" class="btn ghost">â‹¯</button>
  </div>

  <div id="sheet" aria-hidden="true">
    <div id="sheetHeader">
      <strong>Controls</strong>
      <button id="closeSheet" class="btn">Close</button>
    </div>
    <div id="sheetContent">
      <div class="row">
        <span class="pill">Playback</span>
        <button id="toggleMute" class="btn">Unmute</button>
        <button id="swapNow" class="btn ghost">Swap Now</button>
      </div>
      <div class="row">
        <span class="pill">Mode</span>
        <button id="modeGaze" class="btn">Gaze</button>
        <button id="modePointer" class="btn ghost">Pointer</button>
        <button id="toggleCursor" class="btn ghost">Hide Cursor</button>
      </div>
      <div class="row">
        <span class="pill">Upload</span>
        <button id="uploadBtn" class="btn">Add Videos</button>
        <input id="fileInput" type="file" accept="video/*" multiple>
        <button id="resetLibrary" class="btn ghost">Reset Library</button>
      </div>
      <div>
        <div style="opacity:.7; font-size:12px; margin-bottom:6px;">Queue</div>
        <div id="playlist"></div>
      </div>
    </div>
  </div>

<script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
<script>
const video1 = document.getElementById("video1");
const video2 = document.getElementById("video2");
const overlay1 = document.getElementById("overlay1");
const overlay2 = document.getElementById("overlay2");
const cursor = document.getElementById("cursor");
const unlock = document.getElementById("unlock");
const calibrationOverlay = document.getElementById("calibrationOverlay");
const calibrationDot = document.getElementById("calibrationDot");
const startButton = document.getElementById("startButton");
const modeBadge = document.getElementById("modeBadge");
const toggleModeBtn = document.getElementById("toggleMode");
const recalibrateBtn = document.getElementById("recalibrate");
const openSheetBtn = document.getElementById("openSheet");
const closeSheetBtn = document.getElementById("closeSheet");
const sheet = document.getElementById("sheet");
const toggleMuteBtn = document.getElementById("toggleMute");
const swapNowBtn = document.getElementById("swapNow");
const modeGazeBtn = document.getElementById("modeGaze");
const modePointerBtn = document.getElementById("modePointer");
const toggleCursorBtn = document.getElementById("toggleCursor");
const uploadBtn = document.getElementById("uploadBtn");
const fileInput = document.getElementById("fileInput");
const resetLibraryBtn = document.getElementById("resetLibrary");
const playlistEl = document.getElementById("playlist");

// Menu elements
const menuToggle = document.getElementById("menuToggle");
const topMenu = document.getElementById("topMenu");
const menuModeGaze = document.getElementById("menuModeGaze");
const menuModePointer = document.getElementById("menuModePointer");
const menuToggleCursor = document.getElementById("menuToggleCursor");
const menuStartCalibration = document.getElementById("menuStartCalibration");
const menuRecalibrate = document.getElementById("menuRecalibrate");
const menuToggleMute = document.getElementById("menuToggleMute");
const menuSwapNow = document.getElementById("menuSwapNow");
const menuUploadBtn = document.getElementById("menuUploadBtn");
const menuResetLibrary = document.getElementById("menuResetLibrary");
const menuOpenSheet = document.getElementById("menuOpenSheet");

let active = null;
let lastAttended = null;
let mode = localStorage.getItem("mode") || "gaze"; // 'gaze' | 'pointer'
let showCursor = localStorage.getItem("showCursor") !== "false"; // default true
let videoLibrary = [];
let nextIndex = 0;
let isWebgazerStarted = false;
let pointerY = null;

// Gaze tracking variables
let gazeHistory = [];
let lastGazeTime = 0;
let gazeSmoothingFactor = 0.3; // Lower = smoother but less responsive
let minGazeInterval = 100; // Minimum ms between gaze updates
let gazeConfidenceThreshold = 0.6; // Minimum confidence for valid gaze
let lastStableY = null;
let gazeStabilityCounter = 0;
let lastSwitchTime = 0;
let lastStableX = null; // Added for stuck value detection

function defaultLibrary() {
  return [
    { src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4", name: "Big Buck Bunny" },
    { src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4", name: "Elephants Dream" },
    { src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4", name: "For Bigger Blazes" },
    { src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerEscapes.mp4", name: "For Bigger Escapes" },
    { src: "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerFun.mp4", name: "For Bigger Fun" }
  ];
}

function initLibrary(reset=false) {
  if (!reset) {
    try {
      const saved = JSON.parse(localStorage.getItem("library") || "null");
      if (saved && Array.isArray(saved) && saved.length) {
        videoLibrary = saved;
      } else {
        videoLibrary = defaultLibrary();
      }
    } catch(_) {
      videoLibrary = defaultLibrary();
    }
  } else {
    videoLibrary = defaultLibrary();
  }
  nextIndex = 0;
  renderPlaylist();
}

function persistLibrary() {
  localStorage.setItem("library", JSON.stringify(videoLibrary));
}

function renderPlaylist() {
  playlistEl.innerHTML = "";
  videoLibrary.forEach((item, i) => {
    const div = document.createElement('div');
    div.className = 'chip';
    div.textContent = item.name || `Video ${i+1}`;
    playlistEl.appendChild(div);
  });
}

function getVideoOverlay(videoEl) {
  return videoEl === video1 ? overlay1 : overlay2;
}

function showVideoState(videoEl, state, message) {
  const overlay = getVideoOverlay(videoEl);
  overlay.textContent = message;
  videoEl.className = state;
  overlay.className = `video-overlay ${state === 'loading' || state === 'error' ? 'show' : ''}`;
}

function isValidVideoFormat(src) {
  if (!src) return false;
  // Check for supported video formats and avoid problematic sources
  const supportedFormats = /\.(mp4|webm|ogg|mov)(\?.*)?$/i;
  const isDataUrl = src.startsWith('data:');
  const isBlobUrl = src.startsWith('blob:');
  const isHttpUrl = src.startsWith('http');
  
  return isDataUrl || isBlobUrl || (isHttpUrl && supportedFormats.test(src));
}

function loadVideo(videoEl, libIndex) {
  const item = videoLibrary[libIndex % videoLibrary.length];
  if (!item || !isValidVideoFormat(item.src)) {
    showVideoState(videoEl, 'error', 'Invalid video format');
    return;
  }
  
  videoEl.dataset.libIndex = String(libIndex % videoLibrary.length);
  showVideoState(videoEl, 'loading', 'Loading...');
  
  // Clear previous event listeners
  videoEl.onloadeddata = null;
  videoEl.onerror = null;
  videoEl.oncanplay = null;
  videoEl.onloadstart = null;
  
  let loadTimeout;
  
  videoEl.onloadstart = () => {
    // Set a timeout for loading
    loadTimeout = setTimeout(() => {
      if (videoEl.readyState < 2) { // HAVE_CURRENT_DATA
        console.warn('Video load timeout:', item.src);
        showVideoState(videoEl, 'error', 'Load timeout');
        retryWithNextVideo(videoEl, libIndex);
      }
    }, 10000); // 10 second timeout
  };
  
  videoEl.onloadeddata = () => {
    clearTimeout(loadTimeout);
    showVideoState(videoEl, '', '');
    // Auto-play if this is the active video
    if (active === videoEl && !videoEl.muted) {
      videoEl.play().catch(() => {});
    }
  };
  
  videoEl.onerror = () => {
    clearTimeout(loadTimeout);
    console.warn('Video load error:', item.src);
    showVideoState(videoEl, 'error', 'Failed to load');
    retryWithNextVideo(videoEl, libIndex);
  };
  
  videoEl.oncanplay = () => {
    clearTimeout(loadTimeout);
    showVideoState(videoEl, '', '');
  };
  
  videoEl.src = item.src;
  videoEl.load();
}

function retryWithNextVideo(videoEl, currentIndex) {
  // Try next video after a delay
  setTimeout(() => {
    const nextIdx = getNextIndex(currentIndex);
    if (nextIdx !== currentIndex) {
      loadVideo(videoEl, nextIdx);
    } else {
      // If we've tried all videos, show a message
      showVideoState(videoEl, 'error', 'No videos available');
    }
  }, 2000);
}

function getNextIndex(excludeLibIndex) {
  if (!videoLibrary.length) return 0;
  // Ensure not identical to exclude when possible
  for (let i = 0; i < videoLibrary.length; i++) {
    const candidate = (nextIndex + i) % videoLibrary.length;
    if (candidate !== excludeLibIndex) {
      nextIndex = (candidate + 1) % videoLibrary.length;
      return candidate;
    }
  }
  const val = nextIndex; nextIndex = (nextIndex + 1) % videoLibrary.length; return val;
}

function cycleVideo(videoEl) {
  const other = (videoEl === video1) ? video2 : video1;
  const exclude = other.dataset.libIndex ? parseInt(other.dataset.libIndex, 10) : -1;
  const idx = getNextIndex(exclude);
  loadVideo(videoEl, idx);
}

function activate(video) {
  if (active === video) return;
  if (active) active.pause();
  video.play();
  active = video;
}

unlock.addEventListener("click", () => {
  [video1, video2].forEach(v => { v.muted = false; v.play().catch(() => {}); });
  unlock.style.display = "none";
});

toggleMuteBtn.addEventListener('click', () => {
  const willUnmute = video1.muted || video2.muted;
  [video1, video2].forEach(v => { v.muted = !willUnmute ? true : false; if (!v.paused) v.play().catch(()=>{}); });
  if (!willUnmute) unlock.style.display = "block";
});

const points = [[10,20],[90,20],[50,50],[10,80],[90,80],[25,35],[75,35],[25,65],[75,65]];
let currentPoint = 0;
let calibrationData = [];

function showCalibrationPoint() {
  if (currentPoint >= points.length) { calibrationOverlay.style.display = "none"; startTracking(); return; }
  const [px, py] = points[currentPoint];
  calibrationDot.style.left = `${Math.min(Math.max(px, 5), 95)}%`;
  calibrationDot.style.top = `${Math.min(Math.max(py, 5), 95)}%`;
}

calibrationDot.addEventListener("click", () => {
  try { 
    console.log('Calibration point clicked:', { x: calibrationDot.offsetLeft, y: calibrationDot.offsetTop });
    webgazer.recordScreenPosition(calibrationDot.offsetLeft, calibrationDot.offsetTop, "click"); 
    // Store calibration data for validation
    calibrationData.push({
      target: { x: calibrationDot.offsetLeft, y: calibrationDot.offsetTop },
      timestamp: Date.now()
    });
  } catch(error) {
    console.error('Error recording calibration point:', error);
  }
  currentPoint++;
  showCalibrationPoint();
});

function updateModeUI() {
  modeBadge.textContent = `Mode: ${mode === 'gaze' ? 'Gaze' : 'Pointer'}`;
  toggleModeBtn.textContent = mode === 'gaze' ? 'Use Pointer' : 'Use Gaze';
  cursor.style.display = showCursor ? 'block' : 'none';
  toggleCursorBtn.textContent = showCursor ? 'Hide Cursor' : 'Show Cursor';
  localStorage.setItem('mode', mode);
  localStorage.setItem('showCursor', String(showCursor));
  
  // Update menu buttons
  menuModeGaze.classList.toggle('active', mode === 'gaze');
  menuModePointer.classList.toggle('active', mode === 'pointer');
  menuToggleCursor.textContent = showCursor ? 'Hide Cursor' : 'Show Cursor';
}

function handleAttentionAt(y) {
  if (typeof y !== 'number') return;
  
  // Add debouncing to prevent rapid switching
  const now = Date.now();
  const minSwitchInterval = 500; // Minimum 500ms between switches
  
  if (showCursor) {
    cursor.style.left = `${Math.max(0, Math.min(window.innerWidth, window.innerWidth / 2))}px`;
    cursor.style.top = `${y}px`;
  }
  
  const half = window.innerHeight / 2;
  let currentlyLookingAt = (y < half) ? video1 : video2;
  
  // Only switch if enough time has passed and we're looking at a different video
  if (currentlyLookingAt !== lastAttended && (now - (lastSwitchTime || 0)) > minSwitchInterval) {
    activate(currentlyLookingAt);
    const nonActive = (currentlyLookingAt === video1) ? video2 : video1;
    cycleVideo(nonActive);
    lastAttended = currentlyLookingAt;
    lastSwitchTime = now;
  }
}

function startPointerTracking() {
  window.addEventListener('pointermove', pointerMoveListener);
  window.addEventListener('pointerdown', pointerMoveListener);
}

function stopPointerTracking() {
  window.removeEventListener('pointermove', pointerMoveListener);
  window.removeEventListener('pointerdown', pointerMoveListener);
}

function pointerMoveListener(e) {
  pointerY = e.clientY;
  handleAttentionAt(pointerY);
}

function smoothGazeData(x, y, confidence) {
  const now = Date.now();
  
  // Only process if enough time has passed and confidence is high enough
  if (now - lastGazeTime < minGazeInterval || confidence < gazeConfidenceThreshold) {
    return null;
  }
  
  // Add to history (keep last 5 points)
  gazeHistory.push({ x, y, confidence, timestamp: now });
  if (gazeHistory.length > 5) {
    gazeHistory.shift();
  }
  
  // Calculate weighted average based on confidence and recency
  let totalWeight = 0;
  let weightedX = 0;
  let weightedY = 0;
  
  gazeHistory.forEach((point, index) => {
    const age = now - point.timestamp;
    const recencyWeight = Math.max(0, 1 - (age / 1000)); // Decay over 1 second
    const confidenceWeight = point.confidence;
    const weight = recencyWeight * confidenceWeight;
    
    weightedX += point.x * weight;
    weightedY += point.y * weight;
    totalWeight += weight;
  });
  
  if (totalWeight === 0) return null;
  
  const smoothedX = weightedX / totalWeight;
  const smoothedY = weightedY / totalWeight;
  
  // Apply exponential smoothing
  const finalX = lastStableY !== null ? 
    (smoothedX * gazeSmoothingFactor) + (lastStableY * (1 - gazeSmoothingFactor)) : 
    smoothedX;
  
  lastGazeTime = now;
  lastStableY = smoothedY;
  lastStableX = smoothedX; // Update lastStableX
  
  return { x: finalX, y: smoothedY };
}

function isGazeStable(y) {
  if (lastStableY === null) {
    lastStableY = y;
    return true;
  }
  
  const diff = Math.abs(y - lastStableY);
  const isStable = diff < 50; // 50px threshold for stability
  
  if (isStable) {
    gazeStabilityCounter++;
  } else {
    gazeStabilityCounter = Math.max(0, gazeStabilityCounter - 1);
  }
  
  // Require 3 stable readings before considering gaze stable
  return gazeStabilityCounter >= 3;
}

function ensureWebgazerStarted() {
  if (isWebgazerStarted) return Promise.resolve();
  try {
    return webgazer
      .setRegression('ridge')
      .showVideo(false)
      .showPredictionPoints(false)
      .setGazeListener(() => {}) // Clear any existing listeners
      .begin()
      .then(() => {
        isWebgazerStarted = true;
        const style = document.createElement('style');
        style.innerHTML = "#webgazerVideoFeed, #webgazerVideoCanvas, #webgazerFaceOverlay, #webgazerFaceFeedbackBox { display: none !important; }";
        document.head.appendChild(style);
        console.log('WebGazer started successfully');
      })
      .catch(err => {
        console.error('WebGazer failed to start:', err);
        throw err;
      });
  } catch (e) {
    console.error('WebGazer initialization error:', e);
    return Promise.reject(e);
  }
}

function startGazeTracking() {
  try {
    // Clear any existing listeners first
    webgazer.clearGazeListener();
    
    // Reset tracking variables
    gazeHistory = [];
    lastGazeTime = 0;
    lastStableY = null;
    gazeStabilityCounter = 0;
    lastSwitchTime = 0;
    lastStableX = null; // Reset lastStableX
    
    console.log('Starting gaze tracking...');
    
    webgazer.setGazeListener((data) => {
      // Debug logging
      if (data && (data.x !== null || data.y !== null)) {
        console.log('Gaze data received:', { x: data.x, y: data.y, confidence: data.confidence });
      }
      
      if (!data || data.x === null || data.y === null) {
        console.log('Invalid gaze data received');
        return;
      }
      
      const x = data.x;
      const y = data.y;
      const confidence = data.confidence || 0.5;
      
      // Enhanced validation - check for stuck values
      if (x < 0 || x > window.innerWidth || y < 0 || y > window.innerHeight) {
        console.log('Gaze data out of bounds:', { x, y });
        return;
      }
      
      // Check for stuck values (same position for too long)
      if (lastStableX !== null && lastStableY !== null) {
        const xDiff = Math.abs(x - lastStableX);
        const yDiff = Math.abs(y - lastStableY);
        if (xDiff < 5 && yDiff < 5) {
          console.log('Gaze data appears stuck, ignoring:', { x, y, xDiff, yDiff });
          return;
        }
      }
      
      // Apply smoothing and filtering
      const smoothed = smoothGazeData(x, y, confidence);
      if (!smoothed) {
        console.log('Gaze data filtered out');
        return;
      }
      
      const { x: filteredX, y: filteredY } = smoothed;
      
      // Check if gaze is stable before updating
      if (!isGazeStable(filteredY)) {
        console.log('Gaze not stable yet');
        return;
      }
      
      // Apply boundary constraints
      const boundedX = Math.max(0, Math.min(window.innerWidth, filteredX));
      const boundedY = Math.max(0, Math.min(window.innerHeight, filteredY));
      
      console.log('Final gaze position:', { x: boundedX, y: boundedY });
      
      if (showCursor) {
        cursor.style.left = `${boundedX}px`;
        cursor.style.top = `${boundedY}px`;
      }
      
      handleAttentionAt(boundedY);
    });
    
    console.log('Gaze tracking started successfully');
  } catch(error) {
    console.error('Error starting gaze tracking:', error);
    // Fallback to pointer mode
    mode = 'pointer';
    updateModeUI();
    startPointerTracking();
    alert("Eye tracking failed. Switched to Pointer mode.");
  }
}

function stopGazeTracking() {
  try { 
    webgazer.clearGazeListener(); 
    console.log('Gaze tracking stopped');
  } catch(error) {
    console.error('Error stopping gaze tracking:', error);
  }
}

function startCalibrationFlow() {
  currentPoint = 0;
  calibrationData = [];
  // Reset gaze tracking variables
  gazeHistory = [];
  lastGazeTime = 0;
  lastStableY = null;
  gazeStabilityCounter = 0;
  calibrationOverlay.style.display = "flex";
  showCalibrationPoint();
}

function finishCalibration() {
  calibrationOverlay.style.display = "none";
  console.log('Calibration completed with', calibrationData.length, 'points');
  
  // Initialize tracking based on current mode
  if (mode === 'gaze') {
    ensureWebgazerStarted().then(() => {
      console.log('Starting gaze tracking after calibration');
      startGazeTracking();
    }).catch(err => {
      console.error('Failed to start WebGazer after calibration:', err);
      mode = 'pointer';
      updateModeUI();
      startPointerTracking();
      alert("Camera access denied. Switched to Pointer mode.");
    });
  } else {
    console.log('Starting pointer tracking after calibration');
    startPointerTracking();
  }
}

startButton.addEventListener("click", async () => {
  startButton.style.display = "none";
  if (mode === 'gaze') {
    // Request camera permission first
    const hasPermission = await requestCameraPermission();
    if (!hasPermission) {
      mode = 'pointer';
      updateModeUI();
      startPointerTracking();
      return;
    }
    
    // Then start WebGazer
    ensureWebgazerStarted().then(() => {
      startCalibrationFlow();
    }).catch(err => {
      mode = 'pointer';
      updateModeUI();
      startPointerTracking();
      alert("Camera access denied. Using Pointer mode.");
      console.error(err);
    });
  } else {
    startCalibrationFlow();
  }
});

// Complete calibration after tapping through points
const origShowCalibrationPoint = showCalibrationPoint;
showCalibrationPoint = function() {
  if (currentPoint >= points.length) { finishCalibration(); return; }
  const [px, py] = points[currentPoint];
  calibrationDot.style.left = `${Math.min(Math.max(px, 5), 95)}%`;
  calibrationDot.style.top = `${Math.min(Math.max(py, 5), 95)}%`;
}

// Menu event listeners
menuToggle.addEventListener('click', () => {
  topMenu.classList.toggle('open');
  menuToggle.textContent = topMenu.classList.contains('open') ? 'âœ• Close' : 'â˜° Menu';
});

// Close menu when clicking outside
document.addEventListener('click', (e) => {
  if (!topMenu.contains(e.target) && !menuToggle.contains(e.target)) {
    topMenu.classList.remove('open');
    menuToggle.textContent = 'â˜° Menu';
  }
});

// Menu button event listeners
menuModeGaze.addEventListener('click', () => { mode = 'gaze'; applyMode(); topMenu.classList.remove('open'); });
menuModePointer.addEventListener('click', () => { mode = 'pointer'; applyMode(); topMenu.classList.remove('open'); });
menuToggleCursor.addEventListener('click', () => { showCursor = !showCursor; updateModeUI(); });
menuStartCalibration.addEventListener('click', async () => { 
  topMenu.classList.remove('open'); 
  menuToggle.textContent = 'â˜° Menu';
  startButton.style.display = "none";
  if (mode === 'gaze') {
    // Request camera permission first
    const hasPermission = await requestCameraPermission();
    if (!hasPermission) {
      mode = 'pointer';
      updateModeUI();
      startPointerTracking();
      return;
    }
    
    // Then start WebGazer
    ensureWebgazerStarted().then(() => {
      startCalibrationFlow();
    }).catch(err => {
      mode = 'pointer';
      updateModeUI();
      startPointerTracking();
      alert("Camera access denied. Using Pointer mode.");
      console.error(err);
    });
  } else {
    startCalibrationFlow();
  }
});
function resetEyeTracking() {
  console.log('Resetting eye tracking...');
  try {
    // Stop current tracking
    stopGazeTracking();
    
    // Reset WebGazer
    if (typeof webgazer !== 'undefined') {
      webgazer.clearGazeListener();
      webgazer.end();
    }
    
    // Reset variables
    isWebgazerStarted = false;
    gazeHistory = [];
    lastGazeTime = 0;
    lastStableY = null;
    gazeStabilityCounter = 0;
    lastSwitchTime = 0;
    lastStableX = null; // Reset lastStableX
    
    console.log('Eye tracking reset complete');
  } catch (error) {
    console.error('Error resetting eye tracking:', error);
  }
}

// Add reset button to menu
menuRecalibrate.addEventListener('click', () => { 
  topMenu.classList.remove('open'); 
  resetEyeTracking();
  startCalibrationFlow(); 
});
menuToggleMute.addEventListener('click', () => { 
  const willUnmute = video1.muted || video2.muted;
  [video1, video2].forEach(v => { v.muted = !willUnmute ? true : false; if (!v.paused) v.play().catch(()=>{}); });
  if (!willUnmute) unlock.style.display = "block";
  menuToggleMute.textContent = willUnmute ? 'Mute' : 'Unmute';
});
menuSwapNow.addEventListener('click', () => {
  const nonActive = (active === video1) ? video2 : video1;
  cycleVideo(nonActive);
});
menuUploadBtn.addEventListener('click', () => { fileInput.click(); });
menuResetLibrary.addEventListener('click', () => { initLibrary(true); persistLibrary(); renderPlaylist(); });
menuOpenSheet.addEventListener('click', () => { 
  topMenu.classList.remove('open'); 
  sheet.classList.add('open'); 
  sheet.setAttribute('aria-hidden','false'); 
});

// Controls wiring
openSheetBtn.addEventListener('click', () => { sheet.classList.add('open'); sheet.setAttribute('aria-hidden','false'); });
closeSheetBtn.addEventListener('click', () => { sheet.classList.remove('open'); sheet.setAttribute('aria-hidden','true'); });
recalibrateBtn.addEventListener('click', () => { sheet.classList.remove('open'); startCalibrationFlow(); });
toggleModeBtn.addEventListener('click', () => {
  mode = mode === 'gaze' ? 'pointer' : 'gaze';
  applyMode();
});
modeGazeBtn.addEventListener('click', () => { mode = 'gaze'; applyMode(); });
modePointerBtn.addEventListener('click', () => { mode = 'pointer'; applyMode(); });
toggleCursorBtn.addEventListener('click', () => { showCursor = !showCursor; updateModeUI(); });
swapNowBtn.addEventListener('click', () => {
  const nonActive = (active === video1) ? video2 : video1;
  cycleVideo(nonActive);
});
uploadBtn.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', (e) => {
  const files = Array.from(e.target.files || []);
  if (!files.length) return;
  
  let validCount = 0;
  let invalidCount = 0;
  
  files.forEach(f => {
    // Validate file type
    const validTypes = ['video/mp4', 'video/webm', 'video/ogg', 'video/quicktime'];
    const isValidType = validTypes.includes(f.type) || /\.(mp4|webm|ogg|mov)$/i.test(f.name);
    
    if (isValidType && f.size > 0) {
      const url = URL.createObjectURL(f);
      videoLibrary.push({ src: url, name: f.name });
      validCount++;
    } else {
      invalidCount++;
    }
  });
  
  if (validCount > 0) {
    persistLibrary();
    renderPlaylist();
    // If we had fewer than 2 before, ensure both screens are filled
    if (!video1.src) loadVideo(video1, 0);
    if (!video2.src) loadVideo(video2, 1);
  }
  
  if (invalidCount > 0) {
    alert(`${invalidCount} file(s) skipped. Please upload MP4, WebM, OGG, or MOV videos.`);
  }
  
  // Clear the input
  e.target.value = '';
});
resetLibraryBtn.addEventListener('click', () => { initLibrary(true); persistLibrary(); renderPlaylist(); });

// Add test function for WebGazer
function testWebGazer() {
  console.log('Testing WebGazer...');
  try {
    if (typeof webgazer === 'undefined') {
      console.error('WebGazer is not loaded');
      return false;
    }
    
    console.log('WebGazer object found:', webgazer);
    console.log('WebGazer methods:', Object.getOwnPropertyNames(webgazer));
    
    return true;
  } catch (error) {
    console.error('Error testing WebGazer:', error);
    return false;
  }
}

// Test WebGazer on page load
window.addEventListener('load', () => {
  setTimeout(() => {
    testWebGazer();
  }, 1000);
});

function applyMode() {
  updateModeUI();
  if (mode === 'gaze') {
    stopPointerTracking();
    ensureWebgazerStarted().then(() => { startGazeTracking(); }).catch(() => {
      mode = 'pointer'; updateModeUI(); startPointerTracking();
    });
  } else {
    stopGazeTracking();
    startPointerTracking();
  }
}

// Add explicit camera permission request function
async function requestCameraPermission() {
  try {
    console.log('Requesting camera permission...');
    const stream = await navigator.mediaDevices.getUserMedia({ 
      video: { 
        width: { ideal: 640 },
        height: { ideal: 480 },
        facingMode: 'user'
      } 
    });
    console.log('Camera permission granted');
    // Stop the stream immediately since WebGazer will request its own
    stream.getTracks().forEach(track => track.stop());
    return true;
  } catch (err) {
    console.error('Camera permission denied:', err);
    if (err.name === 'NotAllowedError') {
      alert('Camera access is required for eye tracking. Please allow camera access and try again.');
    } else if (err.name === 'NotFoundError') {
      alert('No camera detected. Please connect a camera and try again.');
    } else {
      alert('Camera access failed: ' + err.message);
    }
    return false;
  }
}

// Init
initLibrary(false);
loadVideo(video1, 0);
loadVideo(video2, 1);
updateModeUI();

// Start both muted for autoplay compatibility
[video1, video2].forEach(v => { v.muted = true; v.play().catch(()=>{}); });
</script>
</body>
</html>
